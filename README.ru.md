# just-bun

Это позволяет использовать [Bun Shell](https://bun.sh/docs/runtime/shell) для сохранения и запуска команд, 
специфичных для проекта, по аналогии с [just](https://github.com/casey/just).   
Главным преимуществом по сравнению с **just** является то, что Bun Shell  бесшовно нанизывает shell-команды 
на сколь угодно изощренную логику, написанную на TypeScript с мощными средствами Bun-API, включающими в себя, 
в том числе, почти весь Node.js-API.

## Основное использование

Рецепты хранятся в файлах just_bun.ts в рукавах `switch(recipeName)` 
функции `export async function runRecipe(recipeName?: string, args = [])`.   
Пример файла just_bun.ts:
```ts
import { $ } from "bun";

export async function runRecipe(recipeName?: string, args = []) {
    switch (recipeName) {
        case 'run': // recipeName
        case '# compiling in debug mode and running the program': // comment for list
        case 'r': // recipeName alias
        case undefined: // default: for run without recipeName
            await $`cargo run`;
            break;
        case 'build_release':
        case 'b':
            await $`cargo build --release`;
            await $`echo "Result in: ${__dirname}/target/release"`;
            break;
        case 'test':
        case '# args: [<filter>] [-1] // -1: in one thread':
        case 't':
            await $`cargo test ${{raw: args.join(' ').replace('-1', '-- --test-threads=1')}}`;
            break;
        default:
            return console.log(`recipeName error: '${recipeName}'`);
    }
}
```
Теперь в рабочем каталоге содержащем этот just_bun.ts или его дочернем, команда в терминале `jb -l` выведет:
```
◇ List of recipes in ./just_bun.ts:
  run / r <default> # compiling in debug mode and running the program
  build_release / b 
  test / t # args: [<filter>] [-1] // -1: in one thread
```
Команда `jb run` или `jb r` или просто `jb` выполнит: `cargo run`.  
Команда `jb t add -1` выполнит: `cargo test add -- --test-threads=1`.

Если вам удобнее, имя файла рецептов может иметь спереди точку и любой регистр букв до расширения. 
Например, Just_Bun.ts и .JUST_BUN.ts являются допустимыми именами.

Подробнее [oб ограничениях синтаксиса  function runRecipe() - здесь](#ограничения-синтаксиса-function-runrecipe).   
Подробнее [о ситнтаксисе и работе с Bun Shell - здесь](https://bun.sh/docs/runtime/shell). 

## Установка

1.  Установите [Bun](https://bun.sh/), если его ещё нет в вашей системе.
2.  Скопируйте из этого репозитария папку jb_script в удобное для вас место на вашем компьютере. 
    Можно её переименовать, но далее эту папку здесь обозначаю `jb_script/`.
3.  Создайте короткий удобный alias для команды `bun <path to jb_script/>/main.js` вашей основной оболочки. 
    Здесь этот alias я буду обозначать `jb`.    
    *В безопасности запуска jb_script/main.js легко убедиться: он содержит менее 300 строк, 
    хорошо читаем и импортирует только "path" из bun и runRecipe() из ваших файлов рецептов.*  
    Если в вашей системе установлен [Rust](https://www.rust-lang.org/), то вместо создания alias'а оболочки, 
    можете скомпелировать исполняемый файл jb (jb.exe для Windows) из папки bun_script_alias репозитария 
    и поместить его в любую папку из env PATH (напримеp в ~/.bun/bin или в ~/.cargo/bin). 
    Единственное, что он делает - вызывает `bun <path to jb>/../jb_script/main.js` с переданными ему аргументами. 
    Тогда папку jb_script/ необходимо поместить рядом с папкой, куда вы положили файл jb. При желани, 
    можете синхронно переименовать файл и папку в более удобное для вызова имя, 
    например - в **j** (**j.exe** для Windows) и **j_script**/ соответственно.
4.  На этом этапе уже всё работает, но вашему редактору кода требуются объявления @types/bun 
    для автодополнений и контроля типов из Bun-API при редактировании файлов рецептов.   
    Для этого перейдите в терминале в корневой каталог проектов, в которых вы будете использовать файлы 
    рецептов и введите `jb -@`. Это создаст / обновит здесь папку node_modules/ с объявлениями @types/bun.

## Формат и флаги командной строки

Этот раздел так же можно прочитать по команде `jb -h` или `jb --help`

Варианты командной строки:   
  * `jb [-g] [<recipeName> [args]]` - основное использование
  * `jb -f <path/to/recipe/file>.ts [<recipeName> [args]]`
  * `jb -t [<templateSearchLine>]`
  * `jb -nf <path/to/recipe/file>.ts`
  * `jb <flag>`

Флаги:
  * `-g` запускает рецепт из глобального файла рецептов, находяшегося в папке с main.js
  * `-f` запускает рецепт из любого ts-файла, указанного в \<path/to/recipe/file>
  * `-t` создает  в текущей папке новый файл рецептов на основе шаблона, 
        [найденного](#каталог-templates-just_bun) по первым символам, указанным в \<templateSearchLine>
  * `-l` показывает относительный путь и список рецептов текущего файла рецептов
  * `-L` показывает относительный путь и список рецептов глобального файла рецептов
  * `-n` показывает нумерованный список рецептов текущего файла рецептов 
        и предлагает запустить рецепт, указав его номер и [args]
  * `-N` то же, что и `-n`, но для глобального файла рецептов
  * `-nf` то же, что и `-n`, но для для файла \<path/to/recipe/file>.ts
  * `-о` [открывает](#settingsjson) текущий файл рецептов в редакторе
  * `-O` [открывает](#settingsjson) глобальный файл рецептов в редакторе
  * `-p` выводит абсолютный путь к текущему файлу рецептов
  * `-P` выводит абсолютный путь к глобальному файлу рецептов
  * `-@` устанавливает/обновляет node_modules/ c @types/bun в папке текущего файла рецептов, 
        если не находит, то - в текущей папке
  * `-u` [обновляет](#каталог-mainupdate) main.js из интернета
  * `-h`, `--help` выводит справку по формату и флагам командной строки

## Ограничения синтаксиса function runRecipe()

Эти ограничения наложены исключительно для корректного отображения списка рецептов, 
выводимого по флагам `-l`, `-L`, `-n`, `-N`, `-nf`:

Список рецептов формируется по первой в тексте функции инструкции switch от выражения recipeName: 
`switch (recipeName) {...}` и все ограничения касаются только этой инструкции:
1.  Все выражения `case` должны быть строковыми литералами в `"` или `'` кавычках 
    и не содержать в себе ни `"` ни `'` кавычек, включая `case` комментариев (см. следующий пункт). 
    Допускается один `case` на инструкцию с значением `undefined` для рецепта по умолчанию.
2.  Цепочка из нескольких `case` перед общим рукавом операций представляет собой:
    * необязательные комментарии рецепта: `case`, начинающиеся с "#"
    * обязательное имя рецепта: первый `case`- не комментарий 
    * необязательные псевдонимы рецепта

    `case`- комментарии могут быть в любом месте цепочки      
    В список такой рецепт выводится одной строкой: в начале - имя рецепта, затем, если есть, через `/` псевдонимы, 
    разделенные пробелом, и в конце - все комментарии рецепта в одну строку через пробел.   
    `case` с значением `undefined` выводится в список как `<default>` 
    и может быть как псевдонимом, так и первым или единственным в цепочке `case`.
3.  В рукаве операций рецепта, кроме последнего, обязательно наличие внеблокового 
    (не заключенного в фигурные скобки) `break` или `return`.


## Содержание папки jb_script/

##### main.js

main.js - единственный необходимый для обслуживания файлов рецептов файл.   
Ручное редактирование файла main.js не является штатным действием.

##### just_bun.ts

Это файл глобальных рецептов, вызываемый из любого рабочего каталога флагами `-g`, `-L`, `-N`, `-O`. 
Используется для пользовательских рецептов, общих для всех проектов.   
В отличие от текущих файлов рецептов, его имя должно быть строго "just_bun.ts": без точки в начале имени 
и в нижнем регистре.

##### settings.json

Это необязательный файл пользовательских настроек работы main.js, отличных от значений по умолчанию.
Пока используется только раздел "editor" c параметрами:
* fileOpen - командная строка открытия файла в редакторе (по умолчанию - для VS Code: "code --goto %file%").   
Если требуется вообще запретить открытие файлов по флагам `-о`, `-O` и вновь созданных из шаблонов по флагу `-t`, 
значение этого параметра следует установить в "none".
* fileOpenReport - надо ли объявлять в консоли о переданной команде на открытие файла 
либо о запрете fileOpen = "none" (по умолчанию - false).

##### funcs.ts

Это модуль, содержащий экспортируемые пользовательские константы и функции, используемые в любых файлах рецептов. 
Изначально прописанные в нём экспортируемые функции используются в стартовых шаблонах файлов рецептов из папки templates-just_bun/.

##### Каталог templates-just_bun/

Содержит пользовательские шаблоны файлов рецептов. Они будут вызываться по первым символам имени 
командой `jb -t [<templateSearchLine>]`. Если аргумент <templateSearchLine> не передан - будет использован шаблон _.ts   

Если требуется чтобы вновь создаваемые по шаблонам файлы рецептов имели в начале имени точку 
или отличный от нижнего регистр, замените окончание имени этого каталога "just_bun" на требуемое 
(например, для создания файлов .JUST_BUN.ts имя каталога должно быть "templates-.JUST_BUN").

Для переносимости, шаблоны импортируют funcs.ts по относительному пути. Но в вновь создаваемых по ним 
файлах рецептов этот путь будет заменяться на фактический абсолютный.

##### Каталог mainupdate/

Служит для обновления main.js из интернета по команде `jb -u`. Если желаете предотвратить случайное 
обновление main.js, то удалите / переименуйте этот каталог.

## Работа с sh / bash - утилитами

Для полной кросс-платформенной совместимости [Bun Shell реализует набор встроенных команд с именами популярных sh / bash - утилит](https://bun.sh/docs/runtime/shell#builtin-commands). Однако пока, не все они  полностью поддерживают все флаги и опции утилит.   
Лучший способ, при необходимости, вызывать из Bun Shell именно утилиту, а не встроенную команду - создать 
в funcs.ts экспортируемую константу, например с именем "SH" с абсолютным путём 
к расположению ваших sh / bash - утилит (например, в Windows, это обычно "C:\Program Files\Git\usr\bin\\"). 
Тогда, например, если вас не устраивает работа встроенной команды `ls`,  импортировав в файл рецептов `SH`, вы можете заменить вызов встроенной команды    
```await $`ls` ```,  вызовом аналогичной утилиты:    
```await $`${SH}ls` ```

